
# 滑动窗口

这是一个滑动窗口, 它的作用是允许使用者并发处理数据, 使用者可以储存任务进度, 当程序终止后. 使用者可以从这个进度开始继续处理数据.

---

# 示例

```go
func main() {
data := make([]int, 1000) // 待处理数据
maxDataSn := int64(999)   // 最大数据sn

windowSize := 100         // 滑动窗口大小
startDataSn := int64(300) // 从这个数据sn开始处理

// 创建一个滑动窗口
sw := sliding_window.NewSlidingWindow(windowSize, startDataSn)
defer sw.Stop()

for {
sn, err := sw.Next(context.Background())
if err != nil {
log.Fatalf("next err: %v", err)
}

// 模拟异步提交处理
go func() {
// 模拟io延迟
time.Sleep(time.Millisecond * time.Duration(rand.Int31n(50)))
// 数据处理
data[sn] = 1

// 告知处理完成
sw.Ack(sn)
}()

// 所有数据都提交处理了
if sn == maxDataSn {
log.Printf("submit ok")
break
}
}

log.Printf("wait process")

// 等待完成
err := sw.Wait(context.Background(), maxDataSn)
if err != nil {
log.Fatalf("wait err: %v", err)
}

// 检查数据
for i := startDataSn; i <= maxDataSn; i++ {
if data[i] != 1 {
log.Fatalf("data[%d] != 1. %+v", i, data)
}
}
log.Printf("process ok")
}
```

---

# 滑动窗口原理

![](./assets/a.svg)

---

# 内部设计

## 使用环形数据储存滑动窗口内每条数据的处理状态

当滑动窗口移动时, 环形数据的空间可以重复利用, 不需要在 `data` 后面追加数据来储存后续数据的状态

```go
type SlidingWindow struct {
data        []bool        // 环形数据, 表示每条数据是否已处理
dIndex      int           // 环形数据起始位置索引
startDataSn int64         // 起始位置映射表示的数据sn

// ... 其它字段
}
```

`data` 用于储存当前滑动窗口内每一条数据是否已处理. `dIndex` 表示滑动窗口的起点, `startDataSn` 表示在 `data` 中 `dIndex` 窗格对应哪个数据编号.

![](./assets/b.svg)

## 无锁确认数据

使用无缓冲区 channel 解决数据竞争

```go
type SlidingWindow struct {
data        []bool        // 环形数据, 表示每条数据是否已处理
dIndex      int           // 环形数据起始位置索引
startDataSn int64         // 起始位置映射表示的数据sn

ackCh        chan int64 // ack数据通道, 用于并发转串行

// ... 其它字段
}
```

每次数据处理完成后, 调用滑动窗口 `Ack` 确认该数据已处理完成, 滑动窗口此时会更新 `data` 对应的数据状态和更新 `dIndex` 位置. 而使用者在多线程处理数据时, 可能会同时调用 `Ack` , 就会产生数据竞争.

之前的设计是使用加锁的方式保证同时只有一个线程在ack更新数据, 而现在是通过 `channel` 来限制ack更新数据串行的.

## 滑动窗口如何限制多线程数量

使用滑动窗口大小的有缓冲区的 `channel` 限制多线程数量

```go
type SlidingWindow struct {
space       chan struct{} // 滑动窗口可用窗口数量

// ... 其它字段
}
```

每次使用者需要调用 `Next` 获取下一个应该处理的数据编号, 此时滑动窗口会向 `space` 写入数据, 表示占用了一个窗格. 当 `ack` 确认数据已处理时会从 `space` 取出数据以释放窗格占用

## wait 如何实现等待指定进度完成

```go
type SlidingWindow struct {
waitProgressOk int64 // 等待达到指定进度
waitCh         chan struct{}
}
```

使用者调用 `Wait` 时将要等待的数据编号记录到 `waitProgressOk`, 然后使用 `waitCh` 通道获取数据, 此时由于 `waitCh` 通道没有数据会阻塞调用者.
当 `Ack` 确认数据时, 如果该数据为滑动窗口内的第一条, 则滑动窗口开始向右移动. 由于滑动窗口之前的数据都是已处理完成的, 这里只需要检查滑动窗口之前的最大数据是大于等于 `waitProgressOk` 则表示进度已完成.
调用 `close(waitCh)` 关闭通道, 此时 `Wait` 的调用者阻塞被解除.

---

# 注意

## 滑动窗口的大小应该为最大并发线程数的 2 倍

在滑动窗口内, 并非每次数据处理完成都是滑动窗口内的第一条数据, 应该调整滑动窗口的大小以提供更多的窗格, 以在第一条数据未处理完毕时, 其它数据处理完成后释放的线程能立即开始处理后面的数据, 而不是等着窗格移动.

如果每个数据的处理时间相差不多, 一般滑动窗口的大小应该为并发线程数的 2 倍能保证性能的同时最大利用空间, 降低程序终止后下次重启后需要重新处理的数据量.

性能测试程序 `BenchmarkMultithreading` 的结果如下, 可以看到当滑动窗口的大小是线程数的 2 倍时速率得到大幅提升且容量增长最少.

| 线程数    | 滑动窗口容量倍数 | 速率 (op/s) | 相对基准速率倍数 | 每倍数空间效率 (%) | 每倍数空间效率变化 |
| --------- | ---------------- | ----------- | ---------------- | ------------------ | ------------------ |
| **10**    | 1.0x             | 271         | 1.00             | 100.00             | 基准值             |
|           | 1.3x             | 326         | 1.20             | 92.59              | ↓ 7.41%            |
|           | 1.5x             | 373         | 1.38             | 91.91              | ↓ 8.09%            |
|           | 1.8x             | 393         | 1.45             | 80.73              | ↓ 19.27%           |
|           | 2.0x             | 433         | 1.60             | 79.92              | ↓ 20.08%           |
|           | 3.0x             | 408         | 1.51             | 50.22              | ↓ 49.78%           |
|           | 5.0x             | 411         | 1.52             | 30.33              | ↓ 69.67%           |
|           | 10.0x            | 439         | 1.62             | 16.20              | ↓ 83.80%           |
| **100**   | 1.0x             | 2,222       | 1.00             | 100.00             | 基准值             |
|           | 1.3x             | 2,856       | 1.29             | 98.84              | ↓ 1.16%            |
|           | 1.5x             | 3,279       | 1.48             | 98.37              | ↓ 1.63%            |
|           | 1.8x             | 3,853       | 1.73             | 96.31              | ↓ 3.69%            |
|           | 2.0x             | 4,065       | 1.83             | 91.43              | ↓ 8.57%            |
|           | 3.0x             | 4,033       | 1.82             | 60.48              | ↓ 39.52%           |
|           | 5.0x             | 4,076       | 1.84             | 36.68              | ↓ 63.32%           |
|           | 10.0x            | 4,059       | 1.83             | 18.26              | ↓ 81.74%           |
| **1000**  | 1.0x             | 21,033      | 1.00             | 100.00             | 基准值             |
|           | 1.3x             | 27,109      | 1.29             | 99.13              | ↓ 0.87%            |
|           | 1.5x             | 31,351      | 1.49             | 99.36              | ↓ 0.64%            |
|           | 1.8x             | 37,401      | 1.78             | 98.79              | ↓ 1.21%            |
|           | 2.0x             | 40,556      | 1.93             | 96.40              | ↓ 3.60%            |
|           | 3.0x             | 40,957      | 1.95             | 64.91              | ↓ 35.09%           |
|           | 5.0x             | 40,866      | 1.94             | 38.85              | ↓ 61.15%           |
|           | 10.0x            | 40,835      | 1.94             | 19.41              | ↓ 80.59%           |
| **10000** | 1.0x             | 203,129     | 1.00             | 100.00             | 基准值             |
|           | 1.3x             | 264,480     | 1.30             | 100.16             | ↑ 0.16%            |
|           | 1.5x             | 304,879     | 1.50             | 100.06             | ↑ 0.06%            |
|           | 1.8x             | 362,319     | 1.78             | 99.09              | ↓ 0.91%            |
|           | 2.0x             | 394,941     | 1.94             | 97.22              | ↓ 2.78%            |
|           | 3.0x             | 397,614     | 1.96             | 65.25              | ↓ 34.75%           |
|           | 5.0x             | 398,247     | 1.96             | 39.21              | ↓ 60.79%           |
|           | 10.0x            | 399,042     | 1.96             | 19.64              | ↓ 80.36%           |


## 数据处理幂等性需要使用者实现

滑动窗口内存在一些已完成处理的数据. 一旦程序终止, 则滑动窗口内的已完成处理数据的信息就会丢失, 也就是说当程序恢复进度的时候, 会重新处理这些已完成的数据.

---

# Q & A

## 为什么不精确的保存每个数据是否处理完成

我们考虑一个千亿级别的数据量. 想要保存每个数据是否已处理完成需要 9.31GB 储存空间, 即使使用 bit 位也需要占用 11.64GB 的储存空间.

首先每个数据是否完成不应该存放在内存中, 一旦程序异常终止则会丢失这个数据.
存放在redis中则每次需要刷新数据且需要承担io耗时. 而且一旦程序终止后重新启动, 需要从redis读取所有的bit数据, 这对redis来说io太高了.
存放在mysql中则更是灾难性的, 每次数据处理完毕后去更新mysql对mysql都是巨大的消耗.

如果考虑定时刷入数据, 则程序异常终止时必然会有部分数据因为未刷入而丢失信息导致下次运行时重传. 也就是说我们暂时没有想到更好的办法能精确保存每个数据是否完成的同时还要尽量降低io和储存空间, 以及程序终止后重启能尽量快速恢复进度.

---


## 一些被弃用的方案

### 仅储存进度. 串行化执行, 让业务控制并发量. 业务主动告知平台本次处理完成了多少任务量

优点. 业务对进度和并发自主可控

缺点. 业务想要并行执行需要自行实现, 处理速率也需要业务实现, 业务需要主动报告, 平台对任务的速率无法控制.

### 将每个数据扔给mq, 让mq来并行消费调用业务处理

增加了一个新的mq系统. 业务会变得更加复杂. 且, 数据扔给mq会导致数据膨胀, 比如将索引1的数据扔给mq, 除了数据本身之外, mq的系统会为这个数据增加一些mq系统独有的内容来支撑mq运行. 而且增加了对mq的io消耗. 如果数据量非常大则产生非常高的mq系统费用.

### 使用bit位来表示一条数据是否完成, 将bit数据放入redis中

这里通过扫描bit位拿到未完成的一批次数据, 循环产生协程调用业务处理. 处理完成的任务更新bit位.

缺点. 对于100亿数据. 会占用 1.16GB的bit数据来表示. 对redis来说比较高了. 且扫描redis中的为0或1的bit位耗时为O(N)

### 将bit位存放在服务本地内存, 定时刷新到redis

缺点. 1000亿数据每次同步bit位会写入 11.64GB 数据, 对redis负担巨大

### 仅储存任务进度, 将一段数据作为一批次数据, 只有这一批次数据全部执行完毕才会更新进度

优点, 对于进度的储存占用空间忽略不计, 更新io耗时降低为O(1). 将这一批次的数据全部协程扔给业务处理. 如果有错误需要重试这些数据直到这批次数据全部处理完成后才会开始下一批次的处理. 一批次处理完成后就更新任务进度

可以考虑间隔同步进度而不是试试同步进度. 这样可以进一步降低进度同步消耗io, 即使同步失败, 只有节点本身异常导致进度丢失才会真的丢失最新进度.

缺点.

一批次中的数据不一定是同时完成的, 比如业务具备100条的并行处理速度, 当其中50条完成了. 需要等待另外50条也完成才会开始下一批次的处理. 浪费至少一半的节点资源.

一批次中部分数据处理失败虽然会重试, 但是会降低处理速率. 比如业务具备100条的并行处理速度. 我们扔给业务100条数据. 其中有3条失败, 则我们下一次将这3条错误数据扔给业务重试. 此时业务只能并行执行3条. 浪费了97%的资源.
